{
    "docs": [
        {
            "location": "/index.html",
            "text": "Navigate through the wiki pages using sidebar on the right.",
            "title": "Home"
        },
        {
            "location": "/installation/index.html",
            "text": "Build \nXX_STDLIB.pll\n library from sources or get the prebuilt one from \nforms/libraries/XX_STDLIB/dist\n folder\n\n\nUpload the whole project folder to EBS Application Server\n\n\nLaunch \n./install.sh\n and answer \nY\n when prompted",
            "title": "Installation"
        },
        {
            "location": "/devsuite-configuration/index.html",
            "text": "In case you need to use local installation of DevSuite to edit or compile some module / library which depends on STDLIB, do one of the following:\n\n\n\n\nadjust \nFORMS_PATH\n to point to the \ncrossforms-stdlib/forms/libraries/XX_STDLIB/dist\n folder\n\n\ncopy \nXX_STDLIB.pll\n to one of the folders listed in \nFORMS_PATH\n and keep it up to date\n\n\n\n\nFORMS_PATH\n is either an environment variable on Linux or registry key on Windows.",
            "title": "DevSuite configuration"
        },
        {
            "location": "/faq/index.html",
            "text": "What exactly is a \"struct\"? There is no such thing in PL/SQL!\n\u00b6\n\n\nIn the scope of this project, struct is just a PL/SQL record that is usually pre-populated with some sane defaults and comes with an accompaning \nstd_<struct name>\n package. \n\n\nThe package contains at least these two helpers:\n\n\n\n\nnew(...)\n - initializer\n\n\nis_null(...)\n - custom null checker (\nIS NULL\n operator does not work with record types)",
            "title": "FAQ"
        },
        {
            "location": "/faq/index.html#what-exactly-is-a-struct-there-is-no-such-thing-in-plsql",
            "text": "In the scope of this project, struct is just a PL/SQL record that is usually pre-populated with some sane defaults and comes with an accompaning  std_<struct name>  package.   The package contains at least these two helpers:   new(...)  - initializer  is_null(...)  - custom null checker ( IS NULL  operator does not work with record types)",
            "title": "What exactly is a \"struct\"? There is no such thing in PL/SQL!"
        },
        {
            "location": "/usage/project-setup/index.html",
            "text": "Add dependency to your library\n\n\nWhen using newer versions of CrossForms (preferred):\n\n\n\n\nOpen \ncrossforms-module.json\n file in some ditor\n\n\n\n\nAdd \nXX_STDLIB\n string to \ndependencies.libraries\n array like this:\n\n\n{\n\n    \n\"name\"\n:\n \n\"CUSTOM\"\n,\n\n    \n\"type\"\n:\n \n\"library\"\n,\n\n    \n\"dependencies\"\n:\n \n{\n\n        \n\"libraries\"\n:\n \n[\n\n            \n\"APPCORE\"\n,\n\n            \n\"FNDSQF\"\n,\n\n            \n\"XX_STDLIB\"\n\n        \n]\n\n    \n}\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\n\n\nWhen using legacy version of CrossForms:\n\u00b6\n\n\n\n\nOpen \nMETA-PLL\n file in some editor\n\n\n\n\nAdd \n.attach\n \nLIBRARY\n \nXX_STDLIB\n \nEND\n \nNOCONFIRM\n at the top (below existing \n.attach\n commands):\n\n\n.attach\n \nLIBRARY\n \nAPPCORE\n \nEND\n \nNOCONFIRM\n\n\n.attach\n \nLIBRARY\n \nFNDSQF\n \nEND\n \nNOCONFIRM\n\n\n.attach\n \nLIBRARY\n \nXX_STDLIB\n \nEND\n \nNOCONFIRM\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd dependency to Form Module \n\n\nAll dependencies of your form library must also be attached to the form module which is using it. Otherwise you will end up with random, unfixable EBS crashes at runtime.\n\n\n\n\nOpen the Form Module file (.fmb) in Oracle Forms Builder\n\n\nIn \nObject Navigator\n window, click on \nAttached Libraries\n node\n\n\nPress green plus sign button on the left toolbar\n\n\n\n\nType in \nXX_STDLIB\n and press \nAttach\n\n\n\n\nNote: \nXX_STDLIB.pll\n must be available in \nFORMS_PATH\n. See \nDevSuite configuration\n for details.\n\n\n\n\n\n\n\n\n\n\nSave the Form Module (and remember to re-deploy it)",
            "title": "Project setup"
        },
        {
            "location": "/usage/project-setup/index.html#when-using-legacy-version-of-crossforms",
            "text": "Open  META-PLL  file in some editor   Add  .attach   LIBRARY   XX_STDLIB   END   NOCONFIRM  at the top (below existing  .attach  commands):  .attach   LIBRARY   APPCORE   END   NOCONFIRM  .attach   LIBRARY   FNDSQF   END   NOCONFIRM  .attach   LIBRARY   XX_STDLIB   END   NOCONFIRM       Add dependency to Form Module   All dependencies of your form library must also be attached to the form module which is using it. Otherwise you will end up with random, unfixable EBS crashes at runtime.   Open the Form Module file (.fmb) in Oracle Forms Builder  In  Object Navigator  window, click on  Attached Libraries  node  Press green plus sign button on the left toolbar   Type in  XX_STDLIB  and press  Attach   Note:  XX_STDLIB.pll  must be available in  FORMS_PATH . See  DevSuite configuration  for details.      Save the Form Module (and remember to re-deploy it)",
            "title": "When using legacy version of CrossForms:"
        },
        {
            "location": "/usage/event-handling/index.html",
            "text": "To simplify event handling and delegation in PL/SQL code, STDLIB introduces the \nstd_event\n struct. It contains all essential context information such as current block, current item, form name etc. \n\n\nInstead of directly accessing slippery \nSYSTEM\n variables, you can just get the whole context of current event by initializing new struct with \nstd_event.new('CURRENT-EVENT-NAME')\n call like this:\n\n\ndeclare\n\n  \nlc_event\n \nconstant\n \nstd\n.\nevent\n \n:\n=\n \nstd_event\n.\nnew\n(\n'WHEN-NEW-ITEM-INSTANCE'\n);\n\n\nbegin\n\n  \nfnd_message\n.\ndebug\n(\nlc_event\n.\nblock\n.\nname\n);\n\n\nend\n;\n\n\n\n\n\nRecommended convention for new form modules\n\u00b6\n\n\nPL/SQL packages inside the form library:\n\n\nmain.pks\n\u00b6\n\n\ncreate\n \nor\n \nreplace\n \npackage\n \nmain\n \nas\n\n\n  \nprocedure\n \nevent\n(\np_event\n \nin\n \nstd\n.\nevent\n);\n\n\n\nend\n \nmain\n;\n\n\n\n\n\nmain.pkb\n\u00b6\n\n\ncreate\n \nor\n \nreplace\n \npackage\n \nbody\n \nmain\n \nas\n\n\n  \nprocedure\n \ninitialize_form\n;\n\n\n  \nprocedure\n \nevent\n(\np_event\n \nin\n \nstd\n.\nevent\n)\n \nis\n\n  \nbegin\n\n    \nif\n \np_event\n.\nname\n \n=\n \n'WHEN-NEW-FORM-INSTANCE'\n \nthen\n\n      \ninitialize_form\n;\n\n      \nreturn\n;\n\n    \nend\n \nif\n;\n\n\n    \n--- other\n\n  \nend\n \nevent\n;\n\n\n  \nprocedure\n \ninitialize_form\n \nis\n\n  \nbegin\n\n    \n--- some initialization logic\n\n\n    \nnull\n;\n\n  \nend\n \nevent\n;\n\n\n\nbegin\n\n  \nfdrcsid\n(\n'$Id$'\n);\n\n\nend\n \nmain\n;\n\n\n\n\n\nevent_router.pks\n\u00b6\n\n\ncreate\n \nor\n \nreplace\n \npackage\n \nevent_router\n \nas\n\n\n  \nprocedure\n \nevent\n;\n\n\n  \nprocedure\n \nevent\n(\np_event_name\n \nin\n \nvarchar2\n);\n\n\n\nend\n \nevent_router\n;\n\n\n\n\n\nevent_router.pkb\n\u00b6\n\n\ncreate\n \nor\n \nreplace\n \npackage\n \nbody\n \nevent_router\n \nas\n\n\n  \nprocedure\n \nevent\n \nis\n\n    \nl_event\n \nstd\n.\nevent\n \n:\n=\n \nstd_global_event\n.\npop\n();\n\n  \nbegin\n\n    \nif\n \nnot\n \nstd_event\n.\nis_null\n(\nl_event\n)\n \nthen\n\n      \nroute\n(\nl_event\n);\n\n    \nend\n \nif\n;\n\n  \nend\n \nevent\n;\n\n\n  \nprocedure\n \nevent\n(\np_event_name\n \nvarchar2\n)\n \nis\n\n  \nbegin\n\n    \nroute\n(\nstd_event\n.\nnew\n(\np_event_name\n));\n\n  \nend\n \nevent\n;\n\n\n  \nprocedure\n \nroute\n(\np_event\n \nin\n \nstd\n.\nevent\n)\n \nis\n\n  \nbegin\n\n    \n-- delegate other events from here to other packages\n\n\n    \n/* Example:\n\n\n\n    item_list_ctrl.event(p_event);\n\n\n    request_creator_ctrl.event(p_event);\n\n\n\n    */\n\n  \nend\n \nroute\n;\n\n\n\nbegin\n\n  \nfdrcsid\n(\n'$Id$'\n);\n\n\nend\n \nevent_router\n;\n \n\n\n\n\nevent_router\n package is responsible only for event delegation and should not contain any complex business logic.\n\n\nmain\n package should contain logic which doesn't really fall into some other, less generic feature group. A good example is form initialization, pre-configuration, opening developer tools etc.\n\n\nIn order to put all of this to work, the \nevent_router.event('<EVENT NAME>');\n call should be added to all triggers of the form module (preferably at the form level, although in some cases it might be needed to define trigger on block or item level due to weird bugs).\n\n\nSample: \nform\n package\n\u00b6\n\n\nform\n is a package with specification only, body is not needed. It is used to describe physical structure of the form in PL/SQL code using structs provided by STDLIB. \n\n\ncreate\n \nor\n \nreplace\n \npackage\n \nform\n \nas\n\n\n\n  \ntype\n \nt_form_items\n;\n\n  \ntype\n \nt_form_blocks\n;\n\n  \ntype\n \nt_form_canvases\n;\n\n  \ntype\n \nt_form_tab_pages\n;\n\n  \ntype\n \nt_form_visual_attributes\n;\n\n  \ntype\n \nt_form_windows\n;\n\n\n  \ntype\n \nb_item_list\n;\n\n  \ntype\n \nb_item_controls\n\n\n\n  \n-- Main exports\n\n\n  \nitems\n \nt_form_items\n;\n\n  \nblocks\n \nt_form_blocks\n;\n\n  \ncanvases\n \nt_form_canvases\n;\n\n  \nvattrs\n \nt_form_visual_attributes\n;\n\n  \nwindows\n \nt_form_windows\n;\n\n\n\n  \n-- Definitons\n\n\n  \ntype\n \nt_form_items\n \nis\n \nrecord\n \n(\n\n    \nitem_list\n \nb_item_list\n,\n\n    \nitem_controls\n \nb_item_controls\n\n  \n);\n\n\n  \ntype\n \nt_form_blocks\n \nis\n \nrecord\n \n(\n\n    \nitem_list\n \nstd\n.\nblock\n \n:\n=\n \nstd_block\n.\nnew\n(\n'item_list'\n),\n\n    \nitem_controls\n \nstd\n.\nblock\n \n:\n=\n \nstd_block\n.\nnew\n(\n'item_controls'\n)\n\n  \n);\n\n\n  \ntype\n \nt_form_canvases\n \nis\n \nrecord\n \n(\n\n    \nmain\n \nstd\n.\ncanvas\n \n:\n=\n \nstd_canvas\n.\nnew\n(\n'main'\n)\n\n  \n);\n\n\n  \ntype\n \nt_form_visual_attributes\n \nis\n \nrecord\n \n(\n\n    \npick_status_in_progress\n \nstd\n.\nvattr\n \n:\n=\n \nstd_vattr\n.\nnew\n(\n'pick_status_in_progress'\n),\n\n    \npick_status_completed\n \nstd\n.\nvattr\n \n:\n=\n \nstd_vattr\n.\nnew\n(\n'pick_status_completed'\n),\n\n    \nstatus_released\n \nstd\n.\nvattr\n \n:\n=\n \nstd_vattr\n.\nnew\n(\n'status_released'\n)\n\n  \n);\n\n\n  \ntype\n \nb_item_list\n \nis\n \nrecord\n \n(\n\n    \nitem_number\n \nstd\n.\nitem\n \n:\n=\n \nstd_item\n.\nnew\n(\n'item_list.item_number'\n),\n\n    \ninventory_item_id\n \nstd\n.\nitem\n \n:\n=\n \nstd_item\n.\nnew\n(\n'item_list.inventory_item_id'\n),\n\n    \nquantity\n \nstd\n.\nitem\n \n:\n=\n \nstd_item\n.\nnew\n(\n'item_list.quantity'\n)\n\n  \n);\n\n\n  \ntype\n \nb_item_controls\n \nis\n \nrecord\n \n(\n\n    \ncomplete\n \nstd\n.\nitem\n \n:\n=\n \nstd_item\n.\nnew\n(\n'item_controls.complete'\n),\n\n    \ncancel\n \nstd\n.\nitem\n \n:\n=\n \nstd_item\n.\nnew\n(\n'item_controls.cancel'\n)\n\n  \n);\n\n\n  \ntype\n \nt_form_windows\n \nis\n \nrecord\n \n(\n\n    \nmain_window\n \nstd\n.\nwindow\n \n:\n=\n \nstd_window\n.\nnew\n(\n'main_window'\n)\n\n  \n);\n\n\n\nend\n \nform\n;\n\n\n\n\n\nSample: \nitem_list_ctrl\n package\n\u00b6\n\n\nThis is just an example package which demonstrates how to manage execution flow based on current context information.\n\n\ncreate\n \nor\n \nreplace\n \npackage\n \nbody\n \nitem_list_ctrl\n \nas\n\n\n  \nprocedure\n \nclose_modal\n;\n\n  \nprocedure\n \nvalidate_quantity\n;\n\n  \nprocedure\n \ncomplete\n;\n\n  \nfunction\n \nis_quantity_too_high\n \nreturn\n \nboolean\n;\n\n\n  \nprocedure\n \nevent\n(\np_event\n \nin\n \nstd\n.\nevent\n)\n \nis\n\n  \nbegin\n    \n    \ncase\n \np_event\n.\nname\n \n      \nwhen\n \n'KEY-EXIT'\n \nthen\n\n        \nif\n \nstd_block\n.\nis_in\n(\n\n          \np_event\n.\nblock\n,\n \n          \nform\n.\nblocks\n.\nitem_list\n,\n \n          \nform\n.\nblocks\n.\nitem_controls\n\n        \n)\n\n        \nthen\n\n          \nclose_modal\n();\n\n        \nend\n \nif\n;\n\n      \nwhen\n \n'WHEN-VALIDATE-ITEM'\n \nthen\n\n        \nif\n \nstd_item\n.\nequals\n(\np_event\n.\nitem\n,\n \nform\n.\nitems\n.\nitem_list\n.\nquantity\n)\n \nthen\n\n          \nvalidate_quantity\n();\n\n        \nend\n \nif\n;\n\n      \nwhen\n \n'WHEN-BUTTON-PRESSED'\n \nthen\n\n        \nif\n \nstd_item\n.\nequals\n(\np_event\n.\nitem\n,\n \nform\n.\nitems\n.\nitem_controls\n.\ncomplete\n)\n \nthen\n\n          \ncomplete\n();\n\n        \nelsif\n \nstd_item\n.\nequals\n(\np_event\n.\nitem\n,\n \nform\n.\nitems\n.\nitem_controls\n.\ncancel\n)\n \nthen\n\n          \nclose_modal\n();\n\n        \nend\n \nif\n;\n\n      \nelse\n\n        \nnull\n;\n\n    \nend\n \ncase\n \np_event\n#\nname\n;\n\n\n    \n...\n\n  \nend\n \nevent\n;\n\n\n\nend\n \nitem_list_ctrl\n;",
            "title": "Event handling"
        },
        {
            "location": "/usage/event-handling/index.html#recommended-convention-for-new-form-modules",
            "text": "PL/SQL packages inside the form library:",
            "title": "Recommended convention for new form modules"
        },
        {
            "location": "/usage/event-handling/index.html#mainpks",
            "text": "create   or   replace   package   main   as \n\n   procedure   event ( p_event   in   std . event );  end   main ;",
            "title": "main.pks"
        },
        {
            "location": "/usage/event-handling/index.html#mainpkb",
            "text": "create   or   replace   package   body   main   as \n\n   procedure   initialize_form ; \n\n   procedure   event ( p_event   in   std . event )   is \n   begin \n     if   p_event . name   =   'WHEN-NEW-FORM-INSTANCE'   then \n       initialize_form ; \n       return ; \n     end   if ; \n\n     --- other \n   end   event ; \n\n   procedure   initialize_form   is \n   begin \n     --- some initialization logic \n\n     null ; \n   end   event ;  begin \n   fdrcsid ( '$Id$' );  end   main ;",
            "title": "main.pkb"
        },
        {
            "location": "/usage/event-handling/index.html#event_routerpks",
            "text": "create   or   replace   package   event_router   as \n\n   procedure   event ; \n\n   procedure   event ( p_event_name   in   varchar2 );  end   event_router ;",
            "title": "event_router.pks"
        },
        {
            "location": "/usage/event-handling/index.html#event_routerpkb",
            "text": "create   or   replace   package   body   event_router   as \n\n   procedure   event   is \n     l_event   std . event   : =   std_global_event . pop (); \n   begin \n     if   not   std_event . is_null ( l_event )   then \n       route ( l_event ); \n     end   if ; \n   end   event ; \n\n   procedure   event ( p_event_name   varchar2 )   is \n   begin \n     route ( std_event . new ( p_event_name )); \n   end   event ; \n\n   procedure   route ( p_event   in   std . event )   is \n   begin \n     -- delegate other events from here to other packages \n\n     /* Example:      item_list_ctrl.event(p_event);      request_creator_ctrl.event(p_event);      */ \n   end   route ;  begin \n   fdrcsid ( '$Id$' );  end   event_router ;    event_router  package is responsible only for event delegation and should not contain any complex business logic.  main  package should contain logic which doesn't really fall into some other, less generic feature group. A good example is form initialization, pre-configuration, opening developer tools etc.  In order to put all of this to work, the  event_router.event('<EVENT NAME>');  call should be added to all triggers of the form module (preferably at the form level, although in some cases it might be needed to define trigger on block or item level due to weird bugs).",
            "title": "event_router.pkb"
        },
        {
            "location": "/usage/event-handling/index.html#sample-form-package",
            "text": "form  is a package with specification only, body is not needed. It is used to describe physical structure of the form in PL/SQL code using structs provided by STDLIB.   create   or   replace   package   form   as \n\n\n   type   t_form_items ; \n   type   t_form_blocks ; \n   type   t_form_canvases ; \n   type   t_form_tab_pages ; \n   type   t_form_visual_attributes ; \n   type   t_form_windows ; \n\n   type   b_item_list ; \n   type   b_item_controls \n\n\n   -- Main exports \n\n   items   t_form_items ; \n   blocks   t_form_blocks ; \n   canvases   t_form_canvases ; \n   vattrs   t_form_visual_attributes ; \n   windows   t_form_windows ; \n\n\n   -- Definitons \n\n   type   t_form_items   is   record   ( \n     item_list   b_item_list , \n     item_controls   b_item_controls \n   ); \n\n   type   t_form_blocks   is   record   ( \n     item_list   std . block   : =   std_block . new ( 'item_list' ), \n     item_controls   std . block   : =   std_block . new ( 'item_controls' ) \n   ); \n\n   type   t_form_canvases   is   record   ( \n     main   std . canvas   : =   std_canvas . new ( 'main' ) \n   ); \n\n   type   t_form_visual_attributes   is   record   ( \n     pick_status_in_progress   std . vattr   : =   std_vattr . new ( 'pick_status_in_progress' ), \n     pick_status_completed   std . vattr   : =   std_vattr . new ( 'pick_status_completed' ), \n     status_released   std . vattr   : =   std_vattr . new ( 'status_released' ) \n   ); \n\n   type   b_item_list   is   record   ( \n     item_number   std . item   : =   std_item . new ( 'item_list.item_number' ), \n     inventory_item_id   std . item   : =   std_item . new ( 'item_list.inventory_item_id' ), \n     quantity   std . item   : =   std_item . new ( 'item_list.quantity' ) \n   ); \n\n   type   b_item_controls   is   record   ( \n     complete   std . item   : =   std_item . new ( 'item_controls.complete' ), \n     cancel   std . item   : =   std_item . new ( 'item_controls.cancel' ) \n   ); \n\n   type   t_form_windows   is   record   ( \n     main_window   std . window   : =   std_window . new ( 'main_window' ) \n   );  end   form ;",
            "title": "Sample: form package"
        },
        {
            "location": "/usage/event-handling/index.html#sample-item_list_ctrl-package",
            "text": "This is just an example package which demonstrates how to manage execution flow based on current context information.  create   or   replace   package   body   item_list_ctrl   as \n\n   procedure   close_modal ; \n   procedure   validate_quantity ; \n   procedure   complete ; \n   function   is_quantity_too_high   return   boolean ; \n\n   procedure   event ( p_event   in   std . event )   is \n   begin     \n     case   p_event . name  \n       when   'KEY-EXIT'   then \n         if   std_block . is_in ( \n           p_event . block ,  \n           form . blocks . item_list ,  \n           form . blocks . item_controls \n         ) \n         then \n           close_modal (); \n         end   if ; \n       when   'WHEN-VALIDATE-ITEM'   then \n         if   std_item . equals ( p_event . item ,   form . items . item_list . quantity )   then \n           validate_quantity (); \n         end   if ; \n       when   'WHEN-BUTTON-PRESSED'   then \n         if   std_item . equals ( p_event . item ,   form . items . item_controls . complete )   then \n           complete (); \n         elsif   std_item . equals ( p_event . item ,   form . items . item_controls . cancel )   then \n           close_modal (); \n         end   if ; \n       else \n         null ; \n     end   case   p_event # name ; \n\n     ... \n   end   event ;  end   item_list_ctrl ;",
            "title": "Sample: item_list_ctrl package"
        }
    ]
}